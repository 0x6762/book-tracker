# Book Tracker - Project Guidelines

## Project Overview
A Flutter book tracking application for Android that helps users manage their reading list and track reading progress with features like search, reading timers, and progress tracking.

## Project Structure
```
lib/
├── application/
│   └── services/          # App-level services (timer, notifications, book management)
│       ├── timer_service.dart           # Flutter UI coordination (native-first)
│       ├── native_timer_service.dart    # Native service bridge
│       ├── notification_service.dart    # App-level notifications (timer handled by native)
│       └── simple_color_extraction_service.dart # Book cover color extraction
├── core/
│   ├── constants/         # App constants and configuration
│   ├── di/               # Dependency injection (ServiceLocator)
│   ├── errors/           # Custom error classes
│   ├── theme/            # UI themes, colors, text styles
│   └── utils/            # Utility functions and helpers
├── data/
│   ├── datasources/      # External data sources (Google Books API)
│   ├── mappers/          # Data transformation between layers
│   ├── repositories/     # Data layer repository implementations
│   ├── book_database.dart # Drift database setup
│   └── book_database.g.dart # Generated database code
├── domain/
│   ├── business/         # Business validation services (keep simple)
│   ├── entities/         # Domain models (Book, ReadingProgress)
│   └── repositories/     # Repository interfaces (contracts)
├── presentation/
│   ├── providers/        # State management (Provider pattern)
│   ├── screens/          # Full screen widgets
│   ├── utils/            # UI-specific utilities
│   └── widgets/          # Reusable UI components
└── main.dart             # App entry point

android/app/src/main/kotlin/
├── com/readr/booktracker/
│   ├── MainActivity.kt           # Flutter activity with method channels
│   └── ReadingTimerService.kt    # Native Android foreground service
└── com/example/book_tracker/
    └── MainActivity.kt           # Legacy activity (can be removed)
```

## Key Technologies & Dependencies
- **State Management**: Provider
- **Database**: Drift (SQLite)
- **HTTP**: Dio + HTTP
- **UI**: Material Design with custom theming
- **Notifications**: Native Android service (primary) + flutter_local_notifications (app-level)
- **Audio**: audioplayers
- **Images**: cached_network_image, palette_generator
- **Environment**: flutter_dotenv
- **Native Integration**: Kotlin method channels for foreground service
- **Color Extraction**: palette_generator with database caching

## Architecture Rules

### File Placement
- **New screens** → `presentation/screens/`
- **Reusable widgets** → `presentation/widgets/`
- **Business validation** → `domain/business/` (keep simple, avoid over-engineering)
- **Data access** → `data/repositories/`
- **State management** → `presentation/providers/`
- **Services** → `application/services/`
- **Database models** → `data/` (with Drift annotations)
- **Domain models** → `domain/entities/`
- **Native Android code** → `android/app/src/main/kotlin/com/readr/booktracker/`

### Naming Conventions
- **Files**: snake_case (e.g., `book_details_screen.dart`)
- **Classes**: PascalCase (e.g., `BookDetailsScreen`)
- **Variables/Functions**: camelCase (e.g., `loadBooks()`)
- **Constants**: UPPER_SNAKE_CASE (e.g., `APP_TITLE`)
- **Providers**: End with `Provider` (e.g., `BookListProvider`)

### State Management (Provider)
- **Provider Types**: `ChangeNotifierProvider` for mutable state, `Provider` for immutable
- **Communication**: Use `context.read<OtherProvider>()` in methods, not in `build()`
- **Persistence**: Use SharedPreferences in services, not in providers
- **Memory**: Always call `dispose()`, cancel subscriptions
- **Patterns**: Single responsibility per provider, use services for business logic
- **Common Gotchas**: Don't call `notifyListeners()` in `build()`, use `addPostFrameCallback`

### Database (Drift)
- Define tables in `book_database.dart`
- Use `@DriftDatabase` for main database class
- Generate code with `dart run build_runner build`
- Keep database operations in repository implementations
- **No business validation in database** - use domain validation services
- **Color Caching**: Use `BookColors` table for extracted book cover colors

### API Integration
- Use **Dio** for HTTP requests
- Keep API calls in `data/datasources/`
- Transform API responses using mappers
- Handle errors gracefully with try-catch

### UI Guidelines
- Follow Material Design principles
- Use custom theme from `core/theme/`
- Implement responsive design
- Use Hero animations for smooth transitions
- Keep widgets small and focused
- Extract reusable components to `presentation/widgets/`

### Color Extraction
- **Service**: Use `SimpleColorExtractionService` for book cover color extraction
- **Caching**: Database persistence via `BookColors` table, memory cache for performance
- **Performance**: Smart loading - instant for cached colors, 500ms delay for new extractions
- **Integration**: Colors extracted in `BookCard` widget for progress bar theming

### Error Handling
- Define custom errors in `core/errors/`
- Handle errors at appropriate layers
- Show user-friendly error messages
- Log errors for debugging

### Native Android Integration
- **Method Channels**: Flutter ↔ Kotlin communication via `reading_timer/native_service`
- **Foreground Service**: `ReadingTimerService.kt` handles persistent timer notifications
- **Service Lifecycle**: Uses `START_STICKY` to survive app termination
- **State Persistence**: SharedPreferences for timer state restoration
- **Notification Channels**: Separate channels for timer vs completion notifications
- **Service Communication**: MainActivity.kt bridges Flutter and native service

### Timer Architecture (Native-First)
- **Native Service**: Single source of truth for timer logic and notifications
- **EventChannel**: Real-time updates via EventChannel stream (no polling)
- **Background Persistence**: Native service survives app termination
- **Notifications**: Silent in-progress, loud completion notifications
- **Flow**: Start → Running → Complete → Progress Update Modal
- **Key Pattern**: Native pushes updates, Flutter receives and updates UI reactively
- **Flutter Role**: UI coordination only - no timer logic or duplicate notifications

## Before Making Changes
1. **Check existing patterns** in similar files
2. **Follow the established folder structure**
3. **Maintain separation of concerns** between layers
4. **Use existing providers** before creating new ones
5. **Follow naming conventions** consistently
6. **Update database schema** if adding new data models
7. **Test state management** changes thoroughly
8. **Use domain validation services** for business rules (keep simple)
9. **Keep database layer pure** - no business logic
10. **Avoid over-engineering** - prefer simple solutions over complex ones
11. **Color extraction** - Use `SimpleColorExtractionService` with database caching
12. **Timer implementation** - Use native-first architecture, avoid Flutter timer logic

## Code Quality
- Use `flutter_lints` rules
- Write clean, readable code
- Add comments for complex logic
- Keep functions small and focused
- Use meaningful variable names
- Handle edge cases appropriately
